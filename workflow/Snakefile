# Version 15/10 Projet detection variants / nv transcrits du cancer du seins Projet Dre. Brunet
# >>> Explication de l'outil 
# 1) star.smk permet de déterminer le QC , trimming et QC du trimming. Puis, prend genome reference du download_genome.smk pour creer lindex de star
# >>> Index star  >>> index du genome de reference (ENSEMBL) pour eviter de lire le genome brut 
# >>> Star_alignement >>> aligne les FASTQ du trimming sur le genome de reference (compare sequences de lecture avec celle du genome pour trouver correspondances optimales) >>> output = .Bam
# 2) variants.smk Declaration des potentiels variants en utilisant les fichiers .Bam (star_alignment)
# >>> Call_variants >>> Appel de FreeBayes pour detecter des SNPs et des Indels >>> output = .VCF
# >>> filter_variants >>> Il sert a verifier la qualité du .VCF (Call_variants) >>> Il prend un script et verifie le la col. 6 du .VCF le seuil QC min est 20
# 3) kallisto.smk Declaration des transcrits 
# >>> build_transcriptome >>> sert a former un transcriptome avec genome.fasta et fichier annotation genomique.gtf >>> transcriptome construit
# >>> kallisto_index >>> Cree un index avec le transcriptome.fasta (build_transcriptome) >>> .fasta
# >>> kallisto_quant >>> Donne l'abondance en Effectuant une pseudo-alignement avec index (kalisto_quant).fasta et les trimmings >>> output  = abundance.tsv
# >>> tx2gene >>> converti les transcrits en gènes avec script python
# >>> filter_gtf_pc_genes >>> extraits les gènes codants pour des protéines avec fichier d'annotation.gtf >>> output = .gtf fitlré contenant les gènes codants pour proteines
# >>> merge_kallisto_quant >>> combine les résultats de quantifications de kallisto en 1 df

# >>> Fomonet utilisera build_transcriptome.output.fasta et la liste transcrits par kallisto_quant.output donc
# >>> bd ref + ref.mutee sera utiliser avec la liste de variants
# >>> BD trad. in silico : ORFs  ATG >30codons

#ce qu'il faut, c'est prendre les transcrits et nvx transcrits , creer un nouveau fasta manuellement combinants les variants qui seront trouvés et les renommés #on ne veut pas savoir quil y a le cancer, on le sait deja, mais 
#quel sont les changements proteiques et quel est limpact 
# refaire un .fasta avec les transcrits et les variants obtenus , bien identifié les variants (nom + position) Donc, on va avoir un .fasta avec tout les transcrits, mais avec les variants inclus. 
# Dans le sens que certains transcrits auront des variants , donc faut inclure ses variants dans le fichier la liste de transcrits
# snakemake --profile ../profile_local/ --latency-wait 3
# snakemake --rerun-incomplete --latency-wait 60 --profile ../profile_local/


configfile: "../profile_local/config.yaml"
configfile: "../config/config.json"


directory = os.path.join(config["path"]["fastq_dir"])
id_set = set()
for nom_fichier in os.listdir(directory):
    if nom_fichier.endswith(".fastq.gz"):
        parties = nom_fichier.split('_')
        if len(parties) > 8:  
            id_part = "_".join(parties[:8])  
            id_set.add(id_part)  

id_list = list(id_set) 
print(id_list)
include: "rules/download_genome.smk"  
include: "rules/star.smk"
include: "rules/kallisto.smk"
include: "rules/variants.smk"
#include: "rules/add_variants.smk"

rule all:
    input:
        expand("data/qc/{id}/{id}_R1_001.220405.A00516.AHVHTNDSX2_fastqc.html", id=id_list),
        expand("data/qc/{id}/{id}_R2_001.220405.A00516.AHVHTNDSX2_fastqc.html", id=id_list),
        expand("data/trim_galore/{id}/{id}_R1_001.220405.A00516.AHVHTNDSX2_val_1.fq.gz", id=id_list), 
        expand("data/trim_galore/{id}/{id}_R2_001.220405.A00516.AHVHTNDSX2_val_2.fq.gz", id=id_list), 
        expand("data/qc_trim_galore/{id}/{id}_R1_001.220405.A00516.AHVHTNDSX2_val_1_fastqc.html", id=id_list),
        expand("data/qc_trim_galore/{id}/{id}_R2_001.220405.A00516.AHVHTNDSX2_val_2_fastqc.html", id=id_list),
        expand("results/STAR/{id}/Aligned.sortedByCoord.out.bam", id = id_list),   
        expand("results/variants/{id}/20QC_variant.vcf", id=id_list),
#        expand("results/dge/kallisto/{id}/abundance.tsv", id=id_list),
#        expand("results/variants/{id}/transcrits_variants.fa", id=id_list),
#        expand("results/{id}/filtered_transcriptome_with_mutations.fa", id=id_list)
#        expand("results/variants/{id}/annotat_variants.vcf", id=id_list),
#        expand("results/variants/{id}/test_transcripts.fa", id=id_list)
rule download_genome:
    input:
        gff3 = 'data/references/gff3/homo_sapiens.gff3',
        genome = 'data/references/genome_fa/homo_sapiens_genome.fa',

rule quantification: 
    input:
        build_transcriptome = "data/references/kallisto/transcriptome.fa",
        build_index = "data/references/kallisto/transcriptome.fa",
        Kall_quantif = expand("results/dge/kallisto/{id}_tpm.tsv", id=id_list)  # résultat
